<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Recording - Clementime</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
      defer
    ></script>
  </head>
  <body class="bg-orange-50">
    <%- include('partials/navbar') %>

    <div class="container mx-auto p-6" x-data="recordingApp()" x-init="init()">
      <!-- Current/Upcoming Sessions -->
      <div
        class="bg-white rounded-lg shadow-lg border border-orange-100 p-6 mb-6"
      >
        <h2 class="text-2xl font-bold mb-4">üéôÔ∏è Session Recording</h2>

        <!-- Recording Controls -->
        <div class="mb-6">
          <div class="flex items-center space-x-4 mb-4">
            <button
              @click="toggleRecording()"
              :disabled="!isSupported || !selectedSession"
              :class="{
                            'bg-red-500 hover:bg-red-600': isRecording,
                            'bg-green-500 hover:bg-green-600': !isRecording && selectedSession,
                            'bg-gray-400 cursor-not-allowed': !selectedSession || !isSupported
                        }"
              class="text-white font-bold py-3 px-6 rounded-lg transition-all duration-200 flex items-center"
            >
              <span
                x-show="!isRecording && !isPaused"
                class="flex items-center"
              >
                <svg
                  class="w-5 h-5 mr-2"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <circle cx="12" cy="12" r="10" stroke-width="2" />
                  <circle cx="12" cy="12" r="3" fill="currentColor" />
                </svg>
                Start Recording
              </span>
              <span x-show="isRecording" class="flex items-center">
                <svg
                  class="w-5 h-5 mr-2 animate-pulse"
                  fill="currentColor"
                  viewBox="0 0 24 24"
                >
                  <rect x="6" y="6" width="12" height="12" />
                </svg>
                Stop Recording
              </span>
              <span x-show="isPaused" class="flex items-center">
                <svg
                  class="w-5 h-5 mr-2"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                  />
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  />
                </svg>
                Resume Recording
              </span>
            </button>

            <button
              @click="pauseRecording()"
              x-show="isRecording && !isPaused"
              class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg transition-all duration-200"
            >
              <svg
                class="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
            </button>

            <div
              x-show="isRecording || isPaused"
              class="flex items-center space-x-2"
            >
              <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
              <span
                class="text-gray-700 font-mono"
                x-text="recordingTime"
              ></span>
            </div>
          </div>

          <!-- Audio Level Indicator -->
          <div x-show="isRecording" class="mb-4">
            <div class="bg-gray-200 rounded-full h-4 overflow-hidden">
              <div
                class="bg-green-500 h-full transition-all duration-100"
                :style="`width: ${audioLevel}%`"
              ></div>
            </div>
          </div>

          <!-- Session Selector -->
          <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-2"
              >Select Session to Record:</label
            >
            <select
              x-model="selectedSession"
              @change="updateSelectedSessionDetails()"
              class="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              <option value="">-- Select a session --</option>
              <template
                x-for="(session, index) in upcomingSessions"
                :key="index"
              >
                <option
                  :value="JSON.stringify(session)"
                  x-text="formatSessionOption(session)"
                ></option>
              </template>
            </select>
          </div>

          <!-- Selected Session Details -->
          <div
            x-show="selectedSessionDetails"
            class="bg-orange-50 rounded-lg p-4"
          >
            <h3 class="font-semibold mb-2">Session Details:</h3>
            <div class="grid grid-cols-2 gap-2 text-sm">
              <div>
                <span class="text-gray-600">Student:</span>
                <span x-text="selectedSessionDetails?.studentName"></span>
              </div>
              <div>
                <span class="text-gray-600">TA:</span>
                <span x-text="selectedSessionDetails?.taName"></span>
              </div>
              <div>
                <span class="text-gray-600">Date:</span>
                <span
                  x-text="formatDate(selectedSessionDetails?.startTime)"
                ></span>
              </div>
              <div>
                <span class="text-gray-600">Time:</span>
                <span
                  x-text="formatTime(selectedSessionDetails?.startTime)"
                ></span>
                -
                <span
                  x-text="formatTime(selectedSessionDetails?.endTime)"
                ></span>
              </div>
            </div>
          </div>
        </div>

        <!-- Google Drive Authentication (disabled until OAuth is configured) -->
        <div
          class="bg-gray-50 border border-gray-300 text-gray-600 p-4 rounded-lg mb-4"
        >
          <div class="flex items-center justify-between">
            <div>
              <h4 class="font-semibold">üíæ Local Storage</h4>
              <p class="text-sm">
                Recordings are saved to your computer and logged in the database
              </p>
              <p class="text-xs text-gray-500 mt-1">
                Google Drive integration available when OAuth credentials are
                configured
              </p>
            </div>
            <div
              class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm"
            >
              ‚úÖ Active
            </div>
          </div>
        </div>

        <!-- Status Messages -->
        <div
          x-show="statusMessage"
          :class="{
                'bg-green-100 border-green-300 text-green-800': statusType === 'success',
                'bg-red-100 border-red-300 text-red-800': statusType === 'error',
                'bg-yellow-100 border-yellow-300 text-yellow-800': statusType === 'warning'
            }"
          class="p-4 border rounded-lg mb-4"
        >
          <p x-text="statusMessage"></p>
        </div>

        <!-- Browser Support Check -->
        <div
          x-show="!isSupported"
          class="bg-red-100 border border-red-300 text-red-800 p-4 rounded-lg"
        >
          <p class="font-semibold">Browser Not Supported</p>
          <p>
            Your browser does not support audio recording. Please use a modern
            browser like Chrome, Firefox, or Edge.
          </p>
        </div>
      </div>

      <!-- Recent Recordings -->
      <div class="bg-white rounded-lg shadow-lg border border-orange-100 p-6">
        <h2 class="text-2xl font-bold mb-4">üìº Recent Recordings</h2>

        <div x-show="recordings.length === 0" class="text-gray-500">
          No recordings yet. Start recording a session above.
        </div>

        <div x-show="recordings.length > 0" class="space-y-3">
          <template x-for="(recording, idx) in recordings" :key="idx">
            <div
              class="border rounded-lg p-4 hover:bg-gray-50 transition-colors duration-200"
            >
              <div class="flex justify-between items-start">
                <div>
                  <h4
                    class="font-semibold"
                    x-text="recording.properties?.studentName || 'Unknown Student'"
                  ></h4>
                  <p class="text-sm text-gray-600">
                    <span
                      x-text="recording.properties?.taName || 'Unknown TA'"
                    ></span>
                    ‚Ä¢ Week
                    <span
                      x-text="recording.properties?.weekNumber || '?'"
                    ></span>
                    ‚Ä¢
                    <span x-text="formatDate(recording.createdTime)"></span>
                  </p>
                </div>
                <div class="flex space-x-2">
                  <a
                    :href="recording.webViewLink"
                    target="_blank"
                    class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"
                  >
                    View
                  </a>
                  <button
                    @click="deleteRecording(recording.fileId)"
                    class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-sm"
                  >
                    Delete
                  </button>
                </div>
              </div>
            </div>
          </template>
        </div>

        <button
          @click="loadRecordings()"
          class="mt-4 bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded"
        >
          Refresh Recordings
        </button>
      </div>
    </div>

    <script>
      // Define AudioRecorderService inline since module imports aren't working
      class AudioRecorderService {
          constructor(config = {}) {
              this.mediaRecorder = null;
              this.audioChunks = [];
              this.stream = null;
              this.isRecording = false;
              this.recordingStartTime = null;
              this.recordingId = null;
              this.config = {
                  mimeType: 'audio/webm;codecs=opus',
                  audioBitsPerSecond: 128000,
                  ...config
              };
              this.FALLBACK_MIME_TYPES = [
                  'audio/webm;codecs=opus',
                  'audio/webm',
                  'audio/ogg;codecs=opus',
                  'audio/mp4'
              ];
          }

          getSupportedMimeType() {
              const requestedType = this.config.mimeType;
              if (requestedType && MediaRecorder.isTypeSupported(requestedType)) {
                  return requestedType;
              }
              for (const type of this.FALLBACK_MIME_TYPES) {
                  if (MediaRecorder.isTypeSupported(type)) {
                      return type;
                  }
              }
              return '';
          }

          async startRecording(callbacks = {}) {
              if (this.isRecording) {
                  throw new Error('Recording already in progress');
              }
              try {
                  this.stream = await navigator.mediaDevices.getUserMedia({
                      audio: {
                          echoCancellation: true,
                          noiseSuppression: true,
                          autoGainControl: true
                      }
                  });
                  const mimeType = this.getSupportedMimeType();
                  if (!mimeType) {
                      throw new Error('No supported audio recording format found');
                  }
                  const options = {
                      mimeType,
                      audioBitsPerSecond: this.config.audioBitsPerSecond
                  };
                  this.mediaRecorder = new MediaRecorder(this.stream, options);
                  this.audioChunks = [];
                  this.recordingStartTime = new Date();
                  this.recordingId = `recording_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                  this.mediaRecorder.ondataavailable = (event) => {
                      if (event.data.size > 0) {
                          this.audioChunks.push(event.data);
                          callbacks.onDataAvailable?.(event.data);
                      }
                  };

                  this.mediaRecorder.onstop = () => {
                      const audioBlob = new Blob(this.audioChunks, { type: mimeType });
                      callbacks.onStop?.(audioBlob);
                      this.cleanup();
                  };

                  this.mediaRecorder.onerror = (event) => {
                      const error = new Error(`Recording error: ${event.type}`);
                      callbacks.onError?.(error);
                      this.cleanup();
                  };

                  this.mediaRecorder.start(1000);
                  this.isRecording = true;
                  callbacks.onStart?.();
                  return this.recordingId;
              } catch (error) {
                  this.cleanup();
                  throw new Error(`Failed to start recording: ${error.message}`);
              }
          }

          stopRecording() {
              return new Promise((resolve, reject) => {
                  if (!this.mediaRecorder || !this.isRecording) {
                      reject(new Error('No recording in progress'));
                      return;
                  }
                  const mimeType = this.mediaRecorder.mimeType;
                  this.mediaRecorder.onstop = () => {
                      const audioBlob = new Blob(this.audioChunks, { type: mimeType });
                      this.cleanup();
                      resolve(audioBlob);
                  };
                  this.mediaRecorder.stop();
                  this.isRecording = false;
              });
          }

          pauseRecording() {
              if (this.mediaRecorder && this.isRecording && this.mediaRecorder.state === 'recording') {
                  this.mediaRecorder.pause();
              }
          }

          resumeRecording() {
              if (this.mediaRecorder && this.isRecording && this.mediaRecorder.state === 'paused') {
                  this.mediaRecorder.resume();
              }
          }

          cleanup() {
              if (this.stream) {
                  this.stream.getTracks().forEach(track => track.stop());
                  this.stream = null;
              }
              this.mediaRecorder = null;
              this.audioChunks = [];
              this.isRecording = false;
              this.recordingStartTime = null;
          }

          getRecordingDuration() {
              if (this.recordingStartTime) {
                  return Date.now() - this.recordingStartTime;
              }
              return 0;
          }

          static isSupported() {
              return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia && typeof MediaRecorder !== 'undefined');
          }
      }

      function recordingApp() {
          return {
              isSupported: false,
              isRecording: false,
              isPaused: false,
              selectedSession: '',
              selectedSessionDetails: null,
              audioLevel: 0,
              recordingTime: '00:00',
              statusMessage: '',
              statusType: 'info',
              recordings: [],
              recorder: null,
              recordingStartTime: null,
              recordingTimer: null,
              audioContext: null,
              analyser: null,
              microphone: null,
              googleAccessToken: null,
              googleRefreshToken: null,

              // Sessions data from server - include all sessions for testing
              upcomingSessions: <%- JSON.stringify(schedules) %>,

              // Check if user has Google Drive access
              hasGoogleDrive: <%= hasGoogleDrive ? 'true' : 'false' %>,
              userAccessToken: '<%= user && user.accessToken ? user.accessToken : "" %>',
              userRefreshToken: '<%= user && user.refreshToken ? user.refreshToken : "" %>',

              async init() {
                  console.log('üéôÔ∏è Recording App Initializing...');

                  // Check browser support
                  this.isSupported = AudioRecorderService.isSupported();
                  console.log('üì± Browser support for recording:', this.isSupported);

                  if (this.isSupported) {
                      this.recorder = new AudioRecorderService();
                  }

                  // Check for URL parameters to auto-select session
                  this.checkUrlParams();

                  // Log Google Drive authentication status
                  console.log('üîë Google Drive Auth Status:');
                  console.log('  - hasGoogleDrive flag:', this.hasGoogleDrive);
                  console.log('  - userAccessToken present:', !!this.userAccessToken);
                  console.log('  - userAccessToken length:', this.userAccessToken?.length || 0);

                  // Use the existing Google access token from login if available
                  if (this.userAccessToken && this.hasGoogleDrive) {
                      this.googleAccessToken = this.userAccessToken;
                      this.googleRefreshToken = this.userRefreshToken;
                      console.log('‚úÖ Google access token set for Drive integration');
                      console.log('  - Refresh token available:', !!this.googleRefreshToken);
                      await this.getUserInfo();
                      await this.loadRecordings();
                  } else {
                      console.log('‚ùå Google Drive integration not available:');
                      if (!this.userAccessToken) console.log('  - No access token');
                      if (!this.hasGoogleDrive) console.log('  - hasGoogleDrive flag is false');
                  }

                  // Setup audio context for level monitoring
                  if (window.AudioContext || window.webkitAudioContext) {
                      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                      console.log('üéµ Audio context initialized for level monitoring');
                  }

                  console.log('üéôÔ∏è Recording App initialization complete');
              },

              async checkGoogleAuth() {
                  // Check if we have a valid Google access token
                  const token = sessionStorage.getItem('googleAccessToken');
                  if (token) {
                      this.googleAccessToken = token;
                  } else {
                      // Try to get auth URL
                      try {
                          const response = await fetch('/api/recording/auth/url');
                          const data = await response.json();

                          if (!response.ok && data.authUrl) {
                              this.statusMessage = 'Google Drive authentication required. Click here to authenticate.';
                              this.statusType = 'warning';
                              // You could add a button or link to open the auth URL
                          }
                      } catch (error) {
                          console.error('Auth check failed:', error);
                      }
                  }
              },

              formatSessionOption(session) {
                  const date = new Date(session.startTime);
                  return `${session.studentName} - ${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
              },

              updateSelectedSessionDetails() {
                  if (this.selectedSession) {
                      this.selectedSessionDetails = JSON.parse(this.selectedSession);
                  } else {
                      this.selectedSessionDetails = null;
                  }
              },

              formatDate(dateString) {
                  if (!dateString) return '';
                  return new Date(dateString).toLocaleDateString();
              },

              formatTime(dateString) {
                  if (!dateString) return '';
                  return new Date(dateString).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
              },

              checkUrlParams() {
                  const urlParams = new URLSearchParams(window.location.search);
                  const studentName = urlParams.get('student');
                  const sessionTime = urlParams.get('time');
                  const sectionId = urlParams.get('section');
                  const taName = urlParams.get('ta');

                  console.log('üîç Checking URL params for auto-selection:', {
                      student: studentName,
                      time: sessionTime,
                      section: sectionId,
                      ta: taName
                  });

                  console.log('üîç Available sessions:', this.upcomingSessions);

                  if (studentName) {
                      // Find matching session - be more flexible with matching
                      const matchingSession = this.upcomingSessions.find(session => {
                          console.log('üîç Comparing session:', {
                              sessionStudent: session.studentName,
                              sessionTA: session.taName,
                              sessionSection: session.sectionId,
                              sessionTime: session.startTime
                          });

                          // Match by student name and optionally section
                          const studentMatch = session.studentName === studentName;
                          const sectionMatch = !sectionId || session.sectionId === sectionId;
                          const taMatch = !taName || session.taName === taName;

                          return studentMatch && sectionMatch && taMatch;
                      });

                      if (matchingSession) {
                          console.log('‚úÖ Found matching session:', matchingSession);
                          this.selectedSession = JSON.stringify(matchingSession);
                          this.updateSelectedSessionDetails();

                          // Show success message
                          this.statusMessage = `Auto-selected session for ${studentName}`;
                          this.statusType = 'success';

                          // Auto-start recording after a short delay
                          setTimeout(() => {
                              if (!this.isRecording && this.isSupported) {
                                  console.log('üéôÔ∏è Auto-starting recording for selected session');
                                  this.startRecording();
                              }
                          }, 1500);
                      } else {
                          console.log('‚ùå No matching session found for URL params');
                          console.log('Available students:', this.upcomingSessions.map(s => s.studentName));

                          this.statusMessage = `Could not find session for student "${studentName}". Please select manually.`;
                          this.statusType = 'warning';
                      }
                  }
              },

              async toggleRecording() {
                  if (!this.isRecording && !this.isPaused) {
                      await this.startRecording();
                  } else if (this.isPaused) {
                      this.resumeRecording();
                  } else {
                      await this.stopRecording();
                  }
              },

              async startRecording() {
                  if (!this.selectedSessionDetails) {
                      this.statusMessage = 'Please select a session to record';
                      this.statusType = 'error';
                      return;
                  }

                  try {
                      const recordingId = await this.recorder.startRecording({
                          onDataAvailable: (blob) => {
                              console.log('Data chunk available:', blob.size);
                          },
                          onStop: async (blob) => {
                              await this.handleRecordingComplete(blob);
                          },
                          onError: (error) => {
                              this.statusMessage = `Recording error: ${error.message}`;
                              this.statusType = 'error';
                              this.stopRecordingUI();
                          }
                      });

                      this.isRecording = true;
                      this.recordingStartTime = Date.now();
                      this.startRecordingTimer();
                      await this.setupAudioLevelMonitoring();

                      this.statusMessage = 'Recording started successfully';
                      this.statusType = 'success';
                  } catch (error) {
                      this.statusMessage = `Failed to start recording: ${error.message}`;
                      this.statusType = 'error';
                  }
              },

              async stopRecording() {
                  try {
                      const blob = await this.recorder.stopRecording();
                      this.stopRecordingUI();

                      this.statusMessage = 'Recording stopped. Uploading to Google Drive...';
                      this.statusType = 'info';

                      await this.handleRecordingComplete(blob);
                  } catch (error) {
                      this.statusMessage = `Failed to stop recording: ${error.message}`;
                      this.statusType = 'error';
                      this.stopRecordingUI();
                  }
              },

              pauseRecording() {
                  this.recorder.pauseRecording();
                  this.isPaused = true;
                  clearInterval(this.recordingTimer);
              },

              resumeRecording() {
                  this.recorder.resumeRecording();
                  this.isPaused = false;
                  this.startRecordingTimer();
              },

              stopRecordingUI() {
                  this.isRecording = false;
                  this.isPaused = false;
                  this.recordingTime = '00:00';
                  this.audioLevel = 0;
                  clearInterval(this.recordingTimer);

                  if (this.microphone) {
                      this.microphone.disconnect();
                      this.microphone = null;
                  }

                  if (this.analyser) {
                      this.analyser.disconnect();
                      this.analyser = null;
                  }
              },

              startRecordingTimer() {
                  this.recordingTimer = setInterval(() => {
                      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                      const minutes = Math.floor(elapsed / 60);
                      const seconds = elapsed % 60;
                      this.recordingTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                  }, 1000);
              },

              async setupAudioLevelMonitoring() {
                  try {
                      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                      this.microphone = this.audioContext.createMediaStreamSource(stream);
                      this.analyser = this.audioContext.createAnalyser();
                      this.analyser.smoothingTimeConstant = 0.8;
                      this.analyser.fftSize = 1024;

                      this.microphone.connect(this.analyser);

                      const bufferLength = this.analyser.frequencyBinCount;
                      const dataArray = new Uint8Array(bufferLength);

                      const checkAudioLevel = () => {
                          if (!this.isRecording) return;

                          this.analyser.getByteFrequencyData(dataArray);
                          const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                          this.audioLevel = Math.min(100, (average / 128) * 100);

                          requestAnimationFrame(checkAudioLevel);
                      };

                      checkAudioLevel();
                  } catch (error) {
                      console.error('Failed to setup audio monitoring:', error);
                  }
              },

              async handleRecordingComplete(blob) {
                  if (!this.selectedSessionDetails) return;

                  // Save recording locally as download
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  const fileName = `recording_${this.selectedSessionDetails.studentName.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;

                  a.href = url;
                  a.download = fileName;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                  URL.revokeObjectURL(url);

                  // Save metadata to database and optionally to Google Drive
                  try {
                      let dbSaved = false;
                      let driveSaved = false;

                      // Save metadata to database
                      const metadataResponse = await fetch('/api/recording/save-metadata', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                              studentName: this.selectedSessionDetails.studentName,
                              studentEmail: this.selectedSessionDetails.studentEmail,
                              taName: this.selectedSessionDetails.taName,
                              sessionDate: this.selectedSessionDetails.startTime,
                              weekNumber: this.selectedSessionDetails.weekNumber,
                              sectionId: this.selectedSessionDetails.sectionId,
                              fileName: fileName,
                              fileSize: blob.size,
                              duration: Math.floor(this.recorder.getRecordingDuration() / 1000)
                          })
                      });

                      dbSaved = metadataResponse.ok;

                      // If Google Drive is connected, also upload there
                      if (this.googleAccessToken) {
                          console.log('‚òÅÔ∏è Attempting Google Drive upload...');
                          console.log('  - Access token present:', !!this.googleAccessToken);
                          console.log('  - Access token length:', this.googleAccessToken.length);
                          console.log('  - File name:', fileName);
                          console.log('  - File size:', blob.size, 'bytes');

                          try {
                              const formData = new FormData();
                              formData.append('audio', blob, fileName);
                              formData.append('studentName', this.selectedSessionDetails.studentName);
                              formData.append('studentEmail', this.selectedSessionDetails.studentEmail);
                              formData.append('taName', this.selectedSessionDetails.taName);
                              formData.append('sessionDate', this.selectedSessionDetails.startTime);
                              formData.append('weekNumber', this.selectedSessionDetails.weekNumber);
                              formData.append('sectionId', this.selectedSessionDetails.sectionId);

                              console.log('üì§ Sending upload request to /api/recording/upload...');
                              const headers = { 'X-Google-Access-Token': this.googleAccessToken };
                              if (this.googleRefreshToken) {
                                  headers['X-Google-Refresh-Token'] = this.googleRefreshToken;
                              }
                              const uploadResponse = await fetch('/api/recording/upload', {
                                  method: 'POST',
                                  body: formData,
                                  headers
                              });

                              console.log('üì• Upload response status:', uploadResponse.status);
                              console.log('üì• Upload response ok:', uploadResponse.ok);

                              if (!uploadResponse.ok) {
                                  const errorText = await uploadResponse.text();
                                  console.error('‚ùå Drive upload failed with response:', errorText);
                              } else {
                                  const responseData = await uploadResponse.json();
                                  console.log('‚úÖ Drive upload successful:', responseData);
                              }

                              driveSaved = uploadResponse.ok;
                          } catch (driveError) {
                              console.error('‚ùå Google Drive upload failed with error:', driveError);
                          }
                      } else {
                          console.log('‚ö†Ô∏è Skipping Google Drive upload: no access token available');
                      }

                      // Set status message based on what succeeded
                      if (dbSaved && driveSaved) {
                          this.statusMessage = `Recording saved as ${fileName}, logged to database, and uploaded to Google Drive`;
                          this.statusType = 'success';
                          await this.loadRecordings(); // Refresh the list
                      } else if (dbSaved) {
                          this.statusMessage = `Recording saved as ${fileName} and logged to database`;
                          this.statusType = 'success';
                      } else if (driveSaved) {
                          this.statusMessage = `Recording saved as ${fileName} and uploaded to Google Drive`;
                          this.statusType = 'success';
                          await this.loadRecordings(); // Refresh the list
                      } else {
                          this.statusMessage = `Recording saved as ${fileName} (backup logging failed)`;
                          this.statusType = 'warning';
                      }

                  } catch (error) {
                      this.statusMessage = `Recording saved as ${fileName} (backup logging failed)`;
                      this.statusType = 'warning';
                  }
              },

              async getUserInfo() {
                  if (!this.googleAccessToken) return;

                  try {
                      console.log('üë§ Getting Google user info...');
                      const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                          headers: { 'Authorization': `Bearer ${this.googleAccessToken}` }
                      });

                      if (response.ok) {
                          const userInfo = await response.json();
                          console.log('‚úÖ Authenticated Google user:', userInfo.email);
                          console.log('  - Name:', userInfo.name);
                          console.log('  - Picture:', userInfo.picture);
                      } else {
                          console.error('‚ùå Failed to get user info:', response.status);
                      }
                  } catch (error) {
                      console.error('‚ùå Error getting user info:', error);
                  }
              },

              async loadRecordings() {
                  if (!this.googleAccessToken) {
                      this.recordings = [];
                      return;
                  }

                  try {
                      console.log('üìÅ Loading recordings from Google Drive...');
                      const headers = { 'X-Google-Access-Token': this.googleAccessToken };
                      if (this.googleRefreshToken) {
                          headers['X-Google-Refresh-Token'] = this.googleRefreshToken;
                      }
                      const response = await fetch('/api/recording/list', { headers });

                      if (response.ok) {
                          const result = await response.json();
                          this.recordings = result.data || [];
                          console.log('‚úÖ Loaded', this.recordings.length, 'recordings from Drive');
                      } else {
                          console.error('‚ùå Failed to load recordings:', response.status);
                          this.recordings = [];
                      }
                  } catch (error) {
                      console.error('‚ùå Error loading recordings:', error);
                      this.recordings = [];
                  }
              },

              async deleteRecording(fileId) {
                  // Not implemented - recordings are stored locally
                  this.statusMessage = 'Local recordings cannot be deleted from this interface';
                  this.statusType = 'warning';
              }
          };
      }
    </script>
  </body>
</html>
