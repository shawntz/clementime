name: ğŸŠ ClemenTime CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: shawnschwartz/clementime

jobs:
  # Auto-versioning job that creates date-based tags
  version:
    name: ğŸ·ï¸ Create Version Tag
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
      tag_created: ${{ steps.create_tag.outputs.tag_created }}

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ·ï¸ Generate and create version tag
      id: create_tag
      run: |
        # Get current date
        CURRENT_DATE=$(date +%Y.%m.%d)

        # Get latest tag for today
        LATEST_TAG=$(git tag -l "v${CURRENT_DATE}rc*" | sort -V | tail -n1)

        if [ -z "$LATEST_TAG" ]; then
          # No tags for today, start with rc1
          NEW_TAG="v${CURRENT_DATE}rc1"
        else
          # Extract RC number and increment
          RC_NUM=$(echo $LATEST_TAG | sed "s/v${CURRENT_DATE}rc//")
          NEW_RC_NUM=$((RC_NUM + 1))
          NEW_TAG="v${CURRENT_DATE}rc${NEW_RC_NUM}"
        fi

        echo "ğŸ·ï¸ Creating new tag: $NEW_TAG"

        # Create and push the tag
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        git tag -a "$NEW_TAG" -m "ğŸŠ ClemenTime Release $NEW_TAG

        ## ğŸš€ Auto-generated release
        - Release created automatically from main branch
        - Build triggered by commit: ${{ github.sha }}
        - Docker images available at: shawnschwartz/clementime:$NEW_TAG

        ### ğŸ“¦ Installation
        \`\`\`bash
        docker pull shawnschwartz/clementime:$NEW_TAG
        \`\`\`"

        git push origin "$NEW_TAG"

        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "tag_created=true" >> $GITHUB_OUTPUT

  # Test job to ensure code quality before deployment
  test:
    name: ğŸ§ª Test & Validate
    runs-on: ubuntu-latest

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: ğŸ“¦ Install dependencies
      run: npm ci

    - name: ğŸ” Run TypeScript checks
      run: npm run typecheck

    - name: ğŸ§¹ Run linting
      run: npm run lint

    - name: âœ… Run tests
      run: npm test

    - name: ğŸ›¡ï¸ Validate configuration
      run: npm run validate

  # Build and push Docker image
  docker:
    name: ğŸ³ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, version]
    if: github.event_name != 'pull_request' && (always() && !failure() && !cancelled())
    environment: Docker Hub

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”§ Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: ğŸ”§ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ”‘ Login to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: ğŸ“Š Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=pr
          type=raw,value=${{ needs.version.outputs.new_tag }},enable=${{ needs.version.outputs.tag_created == 'true' }}
          type=raw,value=latest,enable=${{ needs.version.outputs.tag_created == 'true' }}

    - name: ğŸ—ï¸ Build and push Docker image
      id: docker-build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Build and push GCloud-specific Docker image
  docker-gcloud:
    name: â˜ï¸ Build & Push GCloud Docker Image
    runs-on: ubuntu-latest
    needs: [test, version]
    if: github.event_name != 'pull_request' && (always() && !failure() && !cancelled())
    environment: Docker Hub

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ”§ Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: ğŸ”§ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ”‘ Login to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: â˜ï¸ Build and push GCloud Docker image
      run: |
        chmod +x ./gcloud-to-dockerhub.sh
        # Use versioned tag with .gcloud extension if we have a new tag
        if [ "${{ needs.version.outputs.tag_created }}" == "true" ]; then
          export TAG="${{ needs.version.outputs.new_tag }}.gcloud"
          export LATEST_TAG="latest.gcloud"
        else
          export TAG="gcloud-latest"
          export LATEST_TAG="latest.gcloud"
        fi
        ./gcloud-to-dockerhub.sh

  # Deploy to staging on develop branch
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [test, docker, docker-gcloud]
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸš€ Deploy to staging
      run: |
        echo "ğŸ¯ Deploying ClemenTime to staging environment..."
        echo "ğŸ³ Docker image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop"
        echo "ğŸ“ Would run deployment scripts here"
        # Add your staging deployment commands here
        # Example: kubectl set image deployment/clementime clementime=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop

  # Deploy to production on main branch or tags
  deploy-production:
    name: ğŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    needs: [test, docker, docker-gcloud, version]
    if: (github.ref == 'refs/heads/main' && always() && !failure() && !cancelled()) || startsWith(github.ref, 'refs/tags/v')
    environment: production

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸŒŸ Deploy to production
      run: |
        echo "ğŸ¯ Deploying ClemenTime to production environment..."
        if [ "${{ needs.version.outputs.tag_created }}" == "true" ]; then
          echo "ğŸ³ Docker image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version.outputs.new_tag }}"
          echo "ğŸ·ï¸ Version: ${{ needs.version.outputs.new_tag }}"
        else
          echo "ğŸ³ Docker image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        fi
        echo "ğŸ“ Would run deployment scripts here"
        # Add your production deployment commands here
        # Example: kubectl set image deployment/clementime clementime=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version.outputs.new_tag || 'latest' }}

  # Create GitHub release automatically
  release:
    name: ğŸ“¦ Create GitHub Release
    runs-on: ubuntu-latest
    needs: [test, docker, docker-gcloud, version]
    if: needs.version.outputs.tag_created == 'true'
    permissions:
      contents: write

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ğŸ“ Generate release notes
      id: release_notes
      run: |
        TAG_NAME="${{ needs.version.outputs.new_tag }}"

        # Get commit messages since last release
        LAST_TAG=$(git tag -l "v*" --sort=-version:refname | grep -v "$TAG_NAME" | head -1)

        if [ -n "$LAST_TAG" ]; then
          COMMITS=$(git log --pretty=format:"- %s (%h)" ${LAST_TAG}..HEAD | head -10)
        else
          COMMITS=$(git log --pretty=format:"- %s (%h)" HEAD~5..HEAD)
        fi

        # Create release notes
        cat << EOF > release_notes.md
        ## ğŸŠ ClemenTime Release $TAG_NAME

        ### ğŸš€ What's New
        $COMMITS

        ### ğŸ³ Docker Images
        - \`docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG_NAME\`
        - \`docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`

        ### ğŸ“¦ Quick Start
        \`\`\`bash
        # Pull the latest image
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG_NAME

        # Run ClemenTime
        docker run -d \\
          --name clementime \\
          -p 3000:3000 \\
          -v ./config.yml:/app/config.yml \\
          -v ./data:/app/data \\
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG_NAME
        \`\`\`

        ---
        **Docker Hub**: [shawnschwartz/clementime](https://hub.docker.com/r/shawnschwartz/clementime)
        **Full Changelog**: [\`$LAST_TAG..$TAG_NAME\`](${{ github.server_url }}/${{ github.repository }}/compare/$LAST_TAG...$TAG_NAME)

        *Made with â¤ï¸ by [@shawntz](https://github.com/shawntz)*
        EOF

    - name: ğŸ“¦ Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.version.outputs.new_tag }}
        name: ${{ needs.version.outputs.new_tag }}
        body_path: release_notes.md
        draft: false
        prerelease: false
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Security scan
  security:
    name: ğŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    needs: [docker, docker-gcloud]
    if: github.event_name != 'pull_request'
    continue-on-error: true  # Make the entire job non-blocking

    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        exit-code: '0'  # Don't fail the build on vulnerabilities
        severity: 'CRITICAL,HIGH'  # Only report critical and high vulnerabilities
        ignore-unfixed: true  # Ignore unfixed vulnerabilities
        vuln-type: 'os,library'
      continue-on-error: true  # Continue even if scan fails

    - name: ğŸ“¤ Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'
        category: 'Trivy'
      continue-on-error: true  # Don't fail if upload fails due to permissions


  # Notification job
  notify:
    name: ğŸ“¢ Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-production, deploy-staging]
    if: always()

    steps:
    - name: ğŸ“¢ Notify deployment status
      run: |
        if [ "${{ needs.deploy-production.result }}" == "success" ]; then
          echo "ğŸ‰ ClemenTime successfully deployed to production!"
          echo "ğŸ³ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        fi

        if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
          echo "ğŸ¯ ClemenTime successfully deployed to staging!"
          echo "ğŸ³ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop"
        fi


        if [ "${{ needs.deploy-production.result }}" == "failure" ] || [ "${{ needs.deploy-staging.result }}" == "failure" ]; then
          echo "âŒ One or more deployments failed"
        fi

        echo "ğŸ“Š View deployment status: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
